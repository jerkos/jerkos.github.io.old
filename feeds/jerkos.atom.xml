<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jerkos</title><link href="/" rel="alternate"></link><link href="/feeds%5Cjerkos.atom.xml" rel="self"></link><id>/</id><updated>2015-03-26T00:00:00+01:00</updated><entry><title>mzDB, a new efficient file format for handling mass spectrometry data</title><link href="/mzdb-a-new-efficient-file-format-for-handling-mass-spectrometry-data.html" rel="alternate"></link><updated>2015-03-26T00:00:00+01:00</updated><author><name>jerkos</name></author><id>tag:,2015-03-26:mzdb-a-new-efficient-file-format-for-handling-mass-spectrometry-data.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;En protéomique, nous commençons à faire face au problème Big Data. On met plus de temps à traiter les données qu&amp;#8217;à les générer. La taille des fichiers d&amp;#8217;acquisition ne cesse d&amp;#8217;augmenter (spectromètre de plus en plus rapide, plus de nouvelles acquisitions,&lt;span class="caps"&gt;SWATH&lt;/span&gt;, &lt;/strong&gt;&lt;/p&gt;</summary><category term="c++"></category><category term="mass-spectrometry"></category><category term="file format"></category><category term="metabolomics"></category><category term="proteomics"></category><category term="mzML"></category></entry><entry><title>mzOS, heuristiques pour l’annotation en métabolomique</title><link href="/mzos-heuristic-based-metabolomics-annotation-tool.html" rel="alternate"></link><updated>2015-03-26T00:00:00+01:00</updated><author><name>jerkos</name></author><id>tag:,2015-03-26:mzos-heuristic-based-metabolomics-annotation-tool.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Ayant passer le plus clair de mon temps (au boulot n&amp;#8217;est ce pas) à développer des outils pour traiter des données de spectrométrie de masse pour la mébolomique et protéomique, il me fallait contribuer très humblement et succintement à ce petit monde et notamment à celui de la&amp;nbsp;métabolomique.&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;En général, le traitement &lt;span class="caps"&gt;MS&lt;/span&gt; en métabolomique (en non ciblé) se découpe en plusieurs&amp;nbsp;phases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;une première pour extraire les signaux des cartes &lt;span class="caps"&gt;LC&lt;/span&gt;/&lt;span class="caps"&gt;MS&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;une deuxième pour aligner et donc ensuite matcher les signaux de plusieurs cartes (ceux correspondant à la même&amp;nbsp;espèce)&lt;/li&gt;
&lt;li&gt;enfin une troisième pour assigner une espèce connue (issue de base de données) ou non à un maximum de signaux. On note ici, qu&amp;#8217;il est toujours de faire un vérification&amp;nbsp;experimentale&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Je me suis attardé sur la troisième phase car c&amp;#8217;est à mon avis la plus critique, en même temps la plus abordable d&amp;#8217;un point de vie algorithmique (pas besoin de traitement de signal, mathématiques -wavelet-&amp;nbsp;etc&amp;#8230;).&lt;/p&gt;
&lt;h3&gt;De quoi s&amp;#8217;agit-il&amp;nbsp;?&lt;/h3&gt;
&lt;p&gt;Comme l&amp;#8217;annonce le titre, mzOS est un petit package python permettant d&amp;#8217;annoter, &lt;em&gt;ie de detecter les adduits et isotopes&lt;/em&gt;, abondant dans les données de spectrométrie de masse, à partir d&amp;#8217;un simple tableau de &lt;em&gt;features&lt;/em&gt;. L&amp;#8217;idée est de le faire tourner après des outils comme &lt;em&gt;&lt;span class="caps"&gt;XCMS&lt;/span&gt;&lt;/em&gt;, référence dans en la matière ou &lt;em&gt;matra&lt;/em&gt; permettant de faire de la détection de features sur un jeu de données (preuve de concept), ou encore le binding python de &lt;em&gt;OpenMS&lt;/em&gt;&amp;nbsp;pyopenms. &lt;/p&gt;
&lt;p&gt;Plusieurs packages R ont déjà été implémentés, notamment un des plus connus &lt;span class="caps"&gt;CAMERA&lt;/span&gt; et plus récemment, des outils visant à assigner à chaque possibilité d&amp;#8217;annotation pour un signal une valeur de probabilité (Probmetab), basés sur des méthodes bayésiennes. Cette valeur de probabilité peut prendre en compte le réseau metabolique de l&amp;#8217;espèce, les ratios entres les isotopes, les temps de rétention prédits et bien d&amp;#8217;autres métriques auxquelles nous n&amp;#8217;avons pas encore pensé j&amp;#8217;imagine. Ces outils sont évidemment intéressant lorque le nombre d&amp;#8217;annotation possible est supérieur à 1. Sachant que les analyseurs de masse sont de plus en plus performant, on s&amp;#8217;acheminera vers la seule annotation possible en combinaison avec une base de données sur les temps de rétention&amp;nbsp;maison.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Pourquoi python&amp;nbsp;?&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Python est un langage simple et lisible comme tout le monde le sait, et possède de nombreux packages pour la science ce qui en fait clairement sa force. On pense notamment à numpy, scipy, scikit-learn. Ainsi, même si c&amp;#8217;est au départ c&amp;#8217;est un langage clairement lent, tout cette &lt;em&gt;stack&lt;/em&gt; permet d&amp;#8217;en faire un langage de programmation majeur dans le monde de la sciences aux cotés de R&amp;nbsp;notamment.&lt;/p&gt;
&lt;h3&gt;Annotations des isotopes et des&amp;nbsp;adduits&lt;/h3&gt;
&lt;p&gt;La procédure d&amp;#8217;annotation des signaux ressemble fortement dans une premier temps à l&amp;#8217;algorithme de &lt;span class="caps"&gt;CAMERA&lt;/span&gt;. Il diffère principalement par la methode de clustering basé sur le temps de rétention (&lt;em&gt;&lt;span class="caps"&gt;DB&lt;/span&gt;-&lt;span class="caps"&gt;SCAN&lt;/span&gt;&lt;/em&gt;) pour regrouper les signaux, puis un clustering hiérarchique basé sur les corrélations inter-échantillons et sur la forme des progiles d&amp;#8217;élution. L&amp;#8217;algorithme utilise ensuite des heuristiques relativement complexes pour lever des ambiguités lors de l&amp;#8217;attribution des isotopes et&amp;nbsp;adduits.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#Annotation determining isotopes and adducts by default&lt;/span&gt;
&lt;span class="n"&gt;peakels_annotator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PeakelsAnnotator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;peakels&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exp_settings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;monoisotopic_peakels&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;peakels_annotator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;annotate&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;db_search&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DatabaseSearch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hmdb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exp_settings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="cp"&gt;#search for a delta of 1 proton, could be anything else&lt;/span&gt;
&lt;span class="cp"&gt;#cumulation is allowed: [&amp;quot;H1&amp;quot;, &amp;quot;H2&amp;quot;]&lt;/span&gt;
&lt;span class="n"&gt;adducts_l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;H1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="n"&gt;metabolites&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;db_search&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assign_formula&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;peakels&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;adducts_l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exp_settings&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mz_tol_ppm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="cp"&gt;#Compute score 1 based on isotopic ratios&lt;/span&gt;
&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;StatsModel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;peakels&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exp_settings&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mz_tol_ppm&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;calculate_score&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="cp"&gt;#Compute metabolite probabilities&lt;/span&gt;
&lt;span class="n"&gt;bi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BayesianInferer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;peakels&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exp_settings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;bi&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;infer_assignment_probabilities&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="cp"&gt;#Exporting results...&lt;/span&gt;
&lt;span class="n"&gt;exporter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ResultsExporter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;peakels&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;exporter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Database&amp;nbsp;annotation&lt;/h3&gt;
&lt;p&gt;L&amp;#8217;ensemble des signaux est recherché dans plusieurs bases de données (&lt;span class="caps"&gt;HMDB&lt;/span&gt;, &lt;span class="caps"&gt;LMSD&lt;/span&gt;, &lt;span class="caps"&gt;KEGG&lt;/span&gt; pour le moment) en spécifiant la charge et l&amp;#8217;adduit. Par exemple, on peut lancer des recherches pour chaque métabolite avec une liste d&amp;#8217;adduits (M+H, M+2H, M+Na pour un mode positif). En effet, après l&amp;#8217;étape d&amp;#8217;annotation, on est en mesure de dire si le signal est signal correspondant à une espèce (monoisotopique). Cependant, on préfère lancer la recherche en ayant aucun à priori par défault. L&amp;#8217;utilisateur peut décider de prendre en compte cette&amp;nbsp;information.&lt;/p&gt;
&lt;p&gt;La recherche est très rapide puisque mzOS contient un base de données sqlite contenant l&amp;#8217;ensemble des différentes&amp;nbsp;bases.&lt;/p&gt;
&lt;p&gt;Plusieurs scores sont ensuite&amp;nbsp;calculés:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;un correspondant à la différence des rapports isotopiques entre un massif observé et massif&amp;nbsp;théorique&lt;/li&gt;
&lt;li&gt;un second prenant en compte le réseau métabolique de l&amp;#8217;espèce (sorte de gap filler), inférant des probabilités (inférence&amp;nbsp;bayésienne).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Vous pourrez trouver le code sur Github, en cliquant judicieusement dans la sidebar de&amp;nbsp;droite.&lt;/p&gt;</summary><category term="python"></category><category term="data-mining"></category><category term="mass-spectrometry"></category><category term="metabolomics"></category></entry><entry><title>Omics Services blog</title><link href="/omics-services-blog.html" rel="alternate"></link><updated>2010-12-03T10:20:00+01:00</updated><author><name>jerkos</name></author><id>tag:,2010-12-03:omics-services-blog.html</id><summary type="html">&lt;p&gt;Hello&amp;nbsp;everyone, &lt;/p&gt;
&lt;p&gt;This a blog for publishing news about the Omics Services company. We want to share a space where we can exchange about technologies employed&amp;nbsp;here.&lt;/p&gt;</summary><category term="hello"></category></entry></feed>