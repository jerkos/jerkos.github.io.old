<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title></title><link href="http://localhost:8000/" rel="alternate"></link><link href="http://localhost:8000/feeds%5Cjerkos.atom.xml" rel="self"></link><id>http://localhost:8000/</id><updated>2015-03-28T00:00:00+01:00</updated><entry><title>mzDB, un format de fichier pour stocker les données de spectrométrie de masse</title><link href="http://localhost:8000/mzdb-un-format-de-fichier-pour-stocker-les-donnees-de-spectrometrie-de-masse.html" rel="alternate"></link><updated>2015-03-28T00:00:00+01:00</updated><author><name>jerkos</name></author><id>tag:localhost:8000,2015-03-28:mzdb-un-format-de-fichier-pour-stocker-les-donnees-de-spectrometrie-de-masse.html</id><summary type="html">&lt;h3&gt;Nécessité de&amp;nbsp;conversion&lt;/h3&gt;
&lt;p&gt;Les chercheurs souvent, cherche à convertir les fichiers bruts constructeurs (fermés binaires) en format de fichier ouvert, notamment dans les standards définis par &lt;span class="caps"&gt;PSI&lt;/span&gt; afin de les traiter par des solutions bioinformatiques maisons bien moins onéreuses, voire libres. Ainsi sont nés les formats basé sur du &lt;span class="caps"&gt;XML&lt;/span&gt;: mzXML, mzML (standard). L&amp;#8217;ouverture du format de stockage, bien que nécessaire a un effet pervers puisque bien souvent, les fichiers convertis sont nettement plus gros en taille que les fichiers&amp;nbsp;d&amp;#8217;origine. &lt;/p&gt;
&lt;h3&gt;Augmentation temps de calcul et de&amp;nbsp;stockage&lt;/h3&gt;
&lt;p&gt;Or, on met désormais plus de temps à traiter les données qu&amp;#8217;à les générer. La taille des fichiers d&amp;#8217;acquisition ne cesse d&amp;#8217;augmenter (spectromètre de plus en plus rapide, plus de nouvelles acquisitions,&lt;span class="caps"&gt;SWATH&lt;/span&gt;, &lt;span class="caps"&gt;DIA&lt;/span&gt;).&lt;/p&gt;
&lt;p&gt;Ces deux phénomènes entrainent la nécessité d&amp;#8217;avoir un espace de stockage couteux et des infrastructures adaptées pour traiter les données en un temps raisonnable (d&amp;#8217;autant que les fichiers xml ne permettent pas d&amp;#8217;accélérer les algorithmes &amp;#8212;du au temps d&amp;#8217;accès aux&amp;nbsp;données&amp;#8212;).&lt;/p&gt;
&lt;h3&gt;Une nouvel espoir&amp;#8230;(paraphrase de Star&amp;nbsp;Wars)&lt;/h3&gt;
&lt;p&gt;J&amp;#8217;ai travaillé, au &lt;span class="caps"&gt;CNRS&lt;/span&gt;, à la création d&amp;#8217;un nouveau format de fichier pour stocker les données de masse, nommé &lt;strong&gt;mzDB&lt;/strong&gt; basé sur SQLite. Il permet de réduire l&amp;#8217;espace de stockage (fichier plus compact au moins d&amp;#8217;un tiers par rapport au fichier xml), d&amp;#8217;accélérer la lecture des spectres, l&amp;#8217;extraction des &lt;span class="caps"&gt;XIC&lt;/span&gt; (eXtracted Ion Chromatogram), tout en étant regardant par rapport aux métadonnées. En un mot, beaucoup d&amp;#8217;avantage par rapport au fichier type&amp;nbsp;xml.&lt;/p&gt;
&lt;p&gt;&lt;img alt="mzdb image" src="images/mzdb.png" /&gt;&lt;/p&gt;
&lt;p&gt;Il y a quelques inconvénients; l&amp;#8217;implémentation actuelle stocke les données sous forme binaire, et est donc plateforme dépendant (e.g. les plateformes ne respectant pas la norme &lt;span class="caps"&gt;IEEE754&lt;/span&gt; tout&amp;nbsp;particulièrement). &lt;/p&gt;
&lt;p&gt;La communauté a semble-t-il pris conscience de ce problème et souhaiterait s&amp;#8217;orienter vers ce type de fichier, plus efficaces. Mais, le temps d&amp;#8217;élaborer un nouveau standard va prendre un certain temps à n&amp;#8217;en pas&amp;nbsp;douter&amp;#8230;&lt;/p&gt;
&lt;h3&gt;Implémentation&lt;/h3&gt;
&lt;p&gt;mzDB a été pensé par faciliter l&amp;#8217;extraction de données de différentes manières, selon 3 scenarii je dirai. A chaque scenario correspond un &lt;strong&gt;index&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;index sur les spectres, permettant une lecture séquentielle spectre à spectre rapide (utilisation classique dans le sens de l&amp;#8217;acquisition, cependant peu performant pour les algorithmes actuellement&amp;nbsp;implémentés)&lt;/li&gt;
&lt;li&gt;index sur ce qu&amp;#8217;on appelle les &lt;em&gt;run-slices&lt;/em&gt;, entité orthogonale au spectre, possédant donc une dimension en mz fixe. Cette index permet d&amp;#8217;écrire des algorithmes particulièrement rapide pour la quantification par&amp;nbsp;exemple.&lt;/li&gt;
&lt;li&gt;index R* &lt;span class="caps"&gt;TREE&lt;/span&gt;, extraction d&amp;#8217;un région particulière. mzDB est plus rapide de plusieurs ordres de magnitude par rapport à tous ses&amp;nbsp;concurrents.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;J&amp;#8217;ai collaboré sur deux&amp;nbsp;aspects: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;la conversion du fichier constructeur en mzDB. La bibliothèque C++ &lt;a href="http://proteowizard.sourceforge.net"&gt;Proteowizard&lt;/a&gt; permet de lire les fichiers &lt;em&gt;raw, wiff&lt;/em&gt; etc&amp;#8230; J&amp;#8217;ai écrit pas mal de code C, C++ low-level pour des questions de&amp;nbsp;performance.&lt;/li&gt;
&lt;li&gt;la partie relecture du fichier mzDB en Java (le reste de notre projet est en&amp;nbsp;Java/Scala)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La publication se trouve &lt;a href="http://www.ncbi.nlm.nih.gov/pubmed/25505153"&gt;ici&lt;/a&gt;, et le code est sur&amp;nbsp;Github.&lt;/p&gt;</summary><category term="c++"></category><category term="mass-spectrometry"></category><category term="file format"></category><category term="metabolomics"></category><category term="proteomics"></category><category term="mzML"></category></entry><entry><title>mzOS, heuristiques pour l’annotation en métabolomique</title><link href="http://localhost:8000/mzos-heuristic-based-metabolomics-annotation-tool.html" rel="alternate"></link><updated>2015-03-28T00:00:00+01:00</updated><author><name>jerkos</name></author><id>tag:localhost:8000,2015-03-28:mzos-heuristic-based-metabolomics-annotation-tool.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Ayant passer le plus clair de mon temps (au boulot n&amp;#8217;est ce pas) à développer des outils pour traiter des données de spectrométrie de masse pour la mébolomique et protéomique, il me fallait contribuer très humblement et succintement à ce petit monde et notamment à celui de la&amp;nbsp;métabolomique.&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;En général, le traitement &lt;span class="caps"&gt;MS&lt;/span&gt; en métabolomique (en non ciblé) se découpe en plusieurs&amp;nbsp;phases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;une première pour extraire les signaux des cartes &lt;span class="caps"&gt;LC&lt;/span&gt;/&lt;span class="caps"&gt;MS&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;une deuxième pour aligner et donc ensuite matcher les signaux de plusieurs cartes (ceux correspondant à la même&amp;nbsp;espèce)&lt;/li&gt;
&lt;li&gt;enfin une troisième pour assigner une espèce connue (issue de base de données) ou non à un maximum de signaux. On note ici, qu&amp;#8217;il est toujours de faire un vérification&amp;nbsp;experimentale&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Je me suis attardé sur la troisième phase car c&amp;#8217;est à mon avis la plus critique, en même temps la plus abordable d&amp;#8217;un point de vie algorithmique (pas besoin de traitement de signal, mathématiques &amp;#8212;wavelet&amp;#8212;&amp;nbsp;etc&amp;#8230;).&lt;/p&gt;
&lt;h3&gt;De quoi s&amp;#8217;agit-il&amp;nbsp;?&lt;/h3&gt;
&lt;p&gt;Comme l&amp;#8217;annonce le titre, mzOS est un petit package python permettant d&amp;#8217;annoter, &lt;em&gt;ie de detecter les adduits et isotopes, abondants dans les données de spectrométrie de masse, constituant du bruit (faux positif notamment)&lt;/em&gt;, à partir d&amp;#8217;un simple tableau de &lt;em&gt;features&lt;/em&gt;. L&amp;#8217;idée est de le faire tourner après des outils comme &lt;a href="http://bioconductor.org/packages/release/bioc/html/xcms.html"&gt;&lt;span class="caps"&gt;XCMS&lt;/span&gt;&lt;/a&gt;, référence en la matière ou &lt;em&gt;matra&lt;/em&gt; permettant de faire de la détection de features sur un jeu de données (bout de code écrit en D constituant une preuve de concept), ou encore le binding python de &lt;a href="http://open-ms.sourceforge.net/"&gt;OpenMS&lt;/a&gt; &lt;em&gt;pyopenms&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;Plusieurs packages R ont déjà été implémentés, notamment un des plus connus &lt;a href="http://bioconductor.org/packages/release/bioc/html/camera.html"&gt;&lt;span class="caps"&gt;CAMERA&lt;/span&gt;&lt;/a&gt; et plus récemment, des outils visant à assigner à chaque possibilité d&amp;#8217;annotation pour un signal une valeur de probabilité (Probmetab), basés sur des méthodes bayésiennes. Cette valeur de probabilité peut prendre en compte le réseau metabolique de l&amp;#8217;espèce, les ratios entres les isotopes, les temps de rétention prédits et bien d&amp;#8217;autres métriques auxquelles nous n&amp;#8217;avons pas encore pensé, j&amp;#8217;imagine. Le modèle peut alors devenir assez complexe. Ces outils sont évidemment intéressant lorque le nombre d&amp;#8217;annotation possible est supérieur à&amp;nbsp;1. &lt;/p&gt;
&lt;p&gt;Sachant que les analyseurs de masse sont de plus en plus performant, on s&amp;#8217;acheminera vers la seule annotation possible en combinaison avec une base de données sur les temps de rétention&amp;nbsp;maison.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Pourquoi python&amp;nbsp;?&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Python est un langage simple et lisible comme tout le monde le sait, et possède de nombreux packages scientifiques ce qui en fait clairement sa force. On pense notamment à &lt;em&gt;numpy, scipy, scikit-learn&lt;/em&gt;. Ainsi, même si c&amp;#8217;est au départ c&amp;#8217;est un langage clairement lent, tout cette &lt;em&gt;stack&lt;/em&gt; permet d&amp;#8217;en faire un langage de programmation majeur dans le monde des sciences aux cotés de R notamment (et des futures nouveaux, &lt;em&gt;Julia, Rust&lt;/em&gt;).&lt;/p&gt;
&lt;h3&gt;Annotations des isotopes et des&amp;nbsp;adduits&lt;/h3&gt;
&lt;p&gt;La procédure d&amp;#8217;annotation des signaux ressemble fortement dans une premier temps à l&amp;#8217;algorithme de &lt;span class="caps"&gt;CAMERA&lt;/span&gt;. Il diffère principalement par la methode de &lt;em&gt;clustering&lt;/em&gt; basé sur le temps de rétention (&lt;em&gt;&lt;span class="caps"&gt;DB&lt;/span&gt;-&lt;span class="caps"&gt;SCAN&lt;/span&gt;&lt;/em&gt;) pour regrouper les signaux, puis un clustering hiérarchique basé sur les corrélations Pearson sur les intensités inter-échantillons et sur la forme des profils d&amp;#8217;élution intra-échantillon. L&amp;#8217;algorithme utilise ensuite des heuristiques relativement complexes pour lever des ambiguités lors de l&amp;#8217;attribution des isotopes et&amp;nbsp;adduits.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#Annotation determining isotopes and adducts by default&lt;/span&gt;
&lt;span class="n"&gt;peakels_annotator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PeakelsAnnotator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;peakels&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exp_settings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;monoisotopic_peakels&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;peakels_annotator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;annotate&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;db_search&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DatabaseSearch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hmdb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exp_settings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="cp"&gt;#search for a delta of 1 proton, could be anything else&lt;/span&gt;
&lt;span class="cp"&gt;#cumulation is allowed: [&amp;quot;H1&amp;quot;, &amp;quot;H2&amp;quot;]&lt;/span&gt;
&lt;span class="n"&gt;adducts_l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;H1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="n"&gt;metabolites&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;db_search&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assign_formula&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;peakels&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;adducts_l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exp_settings&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mz_tol_ppm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="cp"&gt;#Compute score 1 based on isotopic ratios&lt;/span&gt;
&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;StatsModel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;peakels&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exp_settings&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mz_tol_ppm&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;calculate_score&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="cp"&gt;#Compute metabolite probabilities&lt;/span&gt;
&lt;span class="n"&gt;bi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BayesianInferer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;peakels&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exp_settings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;bi&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;infer_assignment_probabilities&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="cp"&gt;#Exporting results...&lt;/span&gt;
&lt;span class="n"&gt;exporter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ResultsExporter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;peakels&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;exporter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Recherche dans les bases de&amp;nbsp;données&lt;/h3&gt;
&lt;p&gt;L&amp;#8217;ensemble des signaux est recherché dans plusieurs bases de données (&lt;span class="caps"&gt;HMDB&lt;/span&gt;, &lt;span class="caps"&gt;LMSD&lt;/span&gt;, &lt;span class="caps"&gt;KEGG&lt;/span&gt; pour le moment) en spécifiant la charge et l&amp;#8217;adduit. Par exemple, on peut lancer des recherches pour chaque métabolite avec une liste d&amp;#8217;adduits (M+H, M+2H, M+Na pour un mode positif). En effet, après l&amp;#8217;étape d&amp;#8217;annotation, on est en mesure de dire si le signal est un signal correspondant à une espèce (monoisotopique). Cependant, on préfère lancer la recherche en ayant aucun à priori par défault. L&amp;#8217;utilisateur peut cependant décider de prendre en compte cette&amp;nbsp;information.&lt;/p&gt;
&lt;p&gt;La recherche est très rapide puisque mzOS contient un base de données SQLite contenant l&amp;#8217;ensemble des différentes&amp;nbsp;bases.&lt;/p&gt;
&lt;p&gt;Plusieurs scores sont ensuite&amp;nbsp;calculés:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;un correspondant à la différence des rapports isotopiques entre un massif observé et massif&amp;nbsp;théorique&lt;/li&gt;
&lt;li&gt;un second prenant en compte le réseau métabolique de l&amp;#8217;espèce (sorte de gap filler), inférant des probabilités (inférence&amp;nbsp;bayésienne).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Un soin important a été porté sur l&amp;#8217;export des résultats. Un export excel est généré, bien complet, retraçant les différents possibilités d&amp;#8217;assignement pour chaque signal. Ce qui permet au &lt;em&gt;massisste&lt;/em&gt; de retourner dans les données brutes comme il adore le faire, pour vérifier à la&amp;nbsp;main.&lt;/p&gt;
&lt;h2&gt;Dans un avenir&amp;nbsp;proche&amp;#8230;&lt;/h2&gt;
&lt;p&gt;J&amp;#8217;aimerais bien à l&amp;#8217;avenir faire une petite &lt;em&gt;&lt;span class="caps"&gt;API&lt;/span&gt;&lt;/em&gt; pour permettre au gens de tester, en faire une sorte &lt;em&gt;SaaS&lt;/em&gt;. Probablement en utilisant Heroku et S3 pour stocker les tableaux de&amp;nbsp;features.&lt;/p&gt;
&lt;p&gt;Vous pourrez trouver le code sur Github, en cliquant judicieusement dans la sidebar de&amp;nbsp;droite.&lt;/p&gt;</summary><category term="python"></category><category term="data-mining"></category><category term="mass-spectrometry"></category><category term="metabolomics"></category></entry></feed>